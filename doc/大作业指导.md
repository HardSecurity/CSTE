# 扩展说明

---

大作业中，你需要在src/unsorted文件夹下新建一个文件夹，其中包括所有你的程序，输入输出，检查攻击是否成功的程序等。
这一路径下有如下文件夹：
+ vul：漏洞程序源代码和可执行文件
+ check：检测程序源代码和可执行文件
+ input：输入数据文件，非攻击输入（正常输入）文件名以`_normal`结尾
+ doc：文档


另外，在这个文件夹下，我们要求一个`define.json`文件。在这一文件中定义好你的样例的所有信息。一个`compile.sh`文件来编译你的所有源代码。

**在完成了所有任务后，请参考[CSTE整体说明](CSTE整体说明.md)来在框架中使用你的攻击样例，检查是否通过。**

## 主程序要求

对于漏洞程序，我们有如下要求：

### 功能

漏洞程序自身包含至少一个漏洞，程序本身读入一个文件进行一定的操作完成正常功能，当读入文件是恶意文件时，被攻击。检测程序在漏洞程序运行结束后，检查是否发生了攻击，攻击是否成功。

所以你至少需要以下4个文件：被攻击程序，至少一个正常输入，至少一个攻击输入，检测程序。

另外，你的源代码和编译选项也是必需的。


### 执行路径

我们要求所有的程序（漏洞和检测）均在你的**顶层文件夹**中执行，这在你的程序中使用了相对路径的情况下尤为重要。

即要求
```$./vul/vul ./input/input.txt```
是可以正常运行的。检测程序同理。

### 输入参数

当此程序**有且仅有一个参数**时，这个参数指向的是输入文件，例如：

```$./vul/vul ./input/input.txt```

程序名为vul，input.txt为输入文件。当输入文件为不同的输入时，程序完成普通的功能和被攻击的功能。之后check程序来检测。

当然，其他参数数量的情况你可以自己定义。

### 检测程序

检测程序是一个一般的可执行程序。运行后打印出检测结果：

+ 成功情况打印“Success：”后面接一些其他提示信息。
+ 失败情况打印“Fail：”后面接一些其他提示信息。
+ 其他情况可以打印“Other：”后面接一些其他提示信息。

**注意：你的程序会被反复执行，别忘了在主程序中清理上次留下的现场。**

例如：你的攻击生成了一个attack.txt的文件，如果该文件存在，那么攻击成功。那么别忘了在主程序开始时删除这一文件。


## Define 文件说明

---

每个攻击样例都需要在文件夹中定义一个define.json文件来说明自身的信息。define.json文件采用标准的json格式。请确定你的json文件语法和格式的正确。如果不确定，请参考网上的教程，并且使用在线工具来校对你的格式。

+ 一个在线的json文件格式校对网站：http://www.bejson.com/。
+ 一个简单的教程：http://www.360doc.com/content/13/0805/16/8074294_304918276.shtml
+ 如果你想了解更多：http://www.json.org/json-zh.html

文件的内容如下：

+ name：攻击样例的名称。
+ designer：设计者名称。
+ email：设计者联系方式。
+ intro：攻击样例的描述。
+ support_run_all：统一为true。
+ support_check：统一为true。
+ bench：统一为"unsorted"。
+ bit：注明是32位还是64位，注意，使用数字类型而不是字符串。
+ vul_type：数组，表示了样例中有哪些漏洞。内容为["stack_overflow", "heap_overflow", "BSS_overflow", "double_free", "use_afer_free", "format_string", "memory_leak", "other", "hybrid_vuls"]中的一个或多个。
+ attack_model：统一为data。
+ vul_path：漏洞程序的相对路径（相对于配置文件当前路径，即样例的根目录。下同）。
+ compile_path：编译的命令或者脚本相对路径（详见例子）。
+ check_path：检测程序的相对路径。
+ default_attack_name：默认的攻击输入名称，是下面attack_class中名称的一个。
+ default_normal_name：默认的正常输入名称，是下面normal_class中名称的一个。
+ normal_class：一个数组，包含了正常输入的集合。每个结构中有以下属性：
    + name：名称
    + intro：描述
    + path：相对路径
+ attack_class：一个数组，包含了攻击输入的集合。每个结构中有以下属性：
    + name：名称
    + intro：描述
    + path：相对路径
    + type：攻击类型
    + goal：攻击目标,数组，内容为["open_shell", "close_shell", "read_file", "write_file", "system_call", "close_dep"]中的一个或多个。
    + security_bypass：是否绕过了下列防御措施（布尔值）：
        + dep：数据不可执行
        + aslr：地址随机化
        + stack_cookie：栈cookie/stack canary
        
注意：标准json文件不支持注释，注释可以使用`"_comment":"A comment."`的方式插入。

## 命名规范

所有名称全部使用英文小写，多个单词之间用下划线“_”隔开。常见的单词可以用缩写，如处理器（cpu），漏洞（vul），文档（doc）等。

攻击整体文件夹，命名为：漏洞名称+设计者标识+编号.


### 其他注意事项

#### Debug与运行的不同

你可能会遇到这种情况，在gdb中调试攻击成功，但是单独运行时却失败了。

原因可能是程序在调试态与正常运行下调用的库可能细节上有不同。这在调试堆漏洞时更可能遇到。
这时你可以尝试在程序中添加一个暂停等待attach，在程序启动后用attach的方法调试，可以避免这一类问题。但注意，最后提交的程序是不能暂定等待输入的。
所以，你可以在环境变量或者参数数量上做文章。

#### 内存布局的变化

内存布局在系统和库在不同的版本中会有变化，当你使用硬编码的地址时，很容易使攻击失败。你可以参照样例中的处理方法，也可以通过增加一个其他漏洞利用并绕过ASLR的方式，这样这一问题就被同时解决了。

